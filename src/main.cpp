#include "Arduino.h"
#include <FastLED.h>

//only once choice here, it has to be pin17 as thats the only 5v pin on the teensy lc
#define ControlPin 17

#define HPixel 20
#define VPixel 5
#define NumberOfLeds HPixel*VPixel

CRGBArray<NumberOfLeds> leds;

int mapping[HPixel][VPixel];

/* C:\Users\\Desktop\s.bmp (02/09/2017 16:05:38)
   StartOffset: 00000000, EndOffset: 00000161, Length: 00000162 */
unsigned char rawData[354] = {
	0x42, 0x4D, 0x62, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00,
	0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x05, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x81, 0x5B, 0xFF, 0x81, 0x5B,
	0xFF, 0x81, 0x5B, 0xFF, 0x81, 0x5B, 0x77, 0xBD, 0xFF, 0x77, 0xBD, 0xFF,
	0x77, 0xBD, 0xFF, 0x0A, 0x4B, 0xFF, 0x0A, 0x4B, 0xFF, 0x0A, 0x4B, 0xFF,
	0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F,
	0x00, 0x33, 0x7F, 0x47, 0xFF, 0x59, 0x47, 0xFF, 0x59, 0x00, 0x33, 0x7F,
	0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0x0A, 0x4B, 0xFF, 0x0A, 0x4B, 0xFF,
	0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF,
	0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F,
	0x0A, 0x4B, 0xFF, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F,
	0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F,
	0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0x30, 0xF1, 0xFF, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0x0A, 0x4B, 0xFF,
	0x0A, 0x4B, 0xFF, 0x0A, 0x4B, 0xFF, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F,
	0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F
};

/* C:\Users\\Desktop\s.bmpc (04/09/2017 21:11:14)
   StartOffset: 00000000, EndOffset: 000000BF, Length: 000000C0 */

unsigned char compressed_image_data[192] = {
	0x42, 0x43, 0x62, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00,
	0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x05, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xFF, 0x81, 0x5B, 0x00,
	0x03, 0x77, 0xBD, 0xFF, 0x00, 0x03, 0x0A, 0x4B, 0xFF, 0x00, 0x02, 0x00,
	0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0x00, 0x02, 0x00, 0x33, 0x7F, 0x00, 0x02,
	0x47, 0xFF, 0x59, 0x00, 0x02, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0x00,
	0x08, 0xFF, 0xF0, 0x4F, 0x00, 0x03, 0x0A, 0x4B, 0xFF, 0x00, 0x02, 0x00,
	0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0x00, 0x04, 0x00, 0x33, 0x7F, 0x0A, 0x4B,
	0xFF, 0x00, 0x0C, 0xFF, 0xF0, 0x4F, 0x0A, 0x4B, 0xFF, 0x00, 0x02, 0x00,
	0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0x00, 0x02, 0x00, 0x33, 0x7F, 0x0A, 0x4B,
	0xFF, 0x00, 0x0E, 0xFF, 0xF0, 0x4F, 0x0A, 0x4B, 0xFF, 0x00, 0x01, 0x00,
	0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0x00, 0x01, 0x00, 0x33, 0x7F, 0x0A, 0x4B,
	0xFF, 0x00, 0x03, 0xFF, 0xF0, 0x4F, 0x30, 0xF1, 0xFF, 0x00, 0x0C, 0xFF,
	0xF0, 0x4F, 0x00, 0x03, 0x0A, 0x4B, 0xFF, 0x00, 0x03, 0xFF, 0xF0, 0x4F
};




void rainbow(int hue);
void single_colour();
void led_mapping();
void bitmap_load_and_render(unsigned char* bitmap_data);
unsigned char * decode_image(unsigned char *compressed_image_data, uint32_t length);

void setup(){

Serial.begin(112500);
//while(!Serial.dtr())
delay(1000);
Serial.println("Start");

pinMode(LED_BUILTIN, OUTPUT);
//setup leds for fast led
FastLED.addLeds<NEOPIXEL,ControlPin>(leds,NumberOfLeds);

//FastLED.setMaxPowerInVoltsAndMilliamps(5, 500);

led_mapping();
for (int v = 0; v < VPixel; v++){
  Serial.println();
  for (int h = 0; h < HPixel; h++ ){
    Serial.print(mapping[h][v]);
    Serial.print("  ");
  }
}

}

void loop(){
  digitalWrite(LED_BUILTIN, HIGH);
  //static uint8_t hue=0;
  //rainbow(hue++);
  //bitmap_load_and_render(&image_data[0]);
  bitmap_load_and_render(&compressed_image_data[0]);
  leds.fadeLightBy(240);
  FastLED.delay(5);
  FastLED.show();
  digitalWrite(LED_BUILTIN, LOW);
}

void led_mapping(){
  uint currentLED = 0;
  int ledcounter = 1;
  for (int v = 0; v < VPixel; v++){
    if (currentLED != 0)
      currentLED += 20;
    if (v % 2){
      ledcounter = -1;
    }else{
      ledcounter = 1;
    }
    for (int h = 0; h < HPixel; h++ ){
      mapping[h][v] = currentLED;
      currentLED += ledcounter;
    }
    //offset extra +=
    currentLED -= ledcounter;
  }
}

void rainbow(int hue){

  for (int v = 0; v < VPixel; v++){
    Serial.println();
    int stephue = hue;
    for (int h = 0; h < HPixel; h++ ){
      leds[mapping[h][v]].setHue(stephue);
      stephue += 10;
    }
  }
}

void bitmap_load_and_render(unsigned char *bitmap_data){
  //read type
  char type[2];
  memcpy(&type,&bitmap_data[0],2);
  Serial.println(type);
  //read size
  uint32_t size;
  memcpy(&size,&bitmap_data[2],4);
  Serial.println(size);
  // read start of data
  uint32_t dataStart;
  memcpy(&dataStart,&bitmap_data[10],4);
  Serial.println(dataStart);
  unsigned char* image_table;
  if(strcmp(type,"BC") == 0){
    image_table = decode_image(&bitmap_data[dataStart], (size - dataStart));
  }else{
    image_table = &bitmap_data[dataStart];
  }
  delay(15);
  //process the image table
  // BGR
  uint32_t currentLocation = 0;
  for (int v = 0; v < VPixel; v++){
    for (int h = 0; h < HPixel; h++ ){
      uint8_t blue = image_table[currentLocation];
      currentLocation++;
      uint8_t green = image_table[currentLocation];
      currentLocation++;
      uint8_t red = image_table[currentLocation];
      currentLocation++;
      leds[mapping[h][v]].setRGB(red,green,blue);
    }
  }
  free(image_table);
}
/*
Used to decode RLE pixel encoded bitmap
REMEMBER TO FREE THE RETURN VALUE AFTER USE!!!!

stil need to deal with padding to multiples of 4
*/
unsigned char * decode_image(unsigned char *compressed_image_data, uint32_t length){
  Serial.println("Compressed Data");
  unsigned char *image_data;
  image_data = (unsigned char *) malloc(length);
  if (image_data == NULL){Serial.println("Malloc Fail");return NULL;};
  unsigned char data;
  uint16_t position = 0;
  uint8_t rep_num = 1;
  uint32_t i = 0;
  while(i < length){
    rep_num = 1;
    data = compressed_image_data[position];
    Serial.println(data);
    // compression signal
    if (data == 0x00){
      // discard header
      position++;
      //get number of repetitions
      rep_num = compressed_image_data[position];
      Serial.println(rep_num);
      //move to red data
      position++;
    }

      //might need to memcopy
      //dont change the position, it has to track for uncompressed!
      //red
      unsigned char blue = compressed_image_data[position];
      position++;
      //green
      unsigned char green = compressed_image_data[position];
      position++;
     //blue
      unsigned char red = compressed_image_data[position];
      position++;

      if (rep_num == 0){
        // used to return on end of frame
        return image_data;
      }

      for (int j = 0; j < rep_num; j++){
        image_data[i] = blue;
        //increment i for each data byte
        i++;
        image_data[i] = green;
        i++;
        image_data[i] = red;
        i++;
      }
  }
  return image_data;
}
