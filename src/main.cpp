#include "Arduino.h"
#include <FastLED.h>

//only once choice here, it has to be pin17 as thats the only 5v pin on the teensy lc
#define ControlPin 17

#define HPixel 20
#define VPixel 5
#define NumberOfLeds HPixel*VPixel

CRGBArray<NumberOfLeds> leds;

int mapping[HPixel][VPixel];

//bitmap
unsigned char image_data[] = {
0x42, 0x4D, 0x62, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x01, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0xC4, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x81, 0x5B, 0xFF, 0x81, 0x5B, 0xFF, 0x81, 0x5B, 0xFF, 0x81, 0x5B, 0x77, 0xBD, 0xFF, 0x77, 0xBD, 0xFF, 0x77, 0xBD, 0xFF, 0x0A, 0x4B, 0xFF, 0x0A, 0x4B, 0xFF, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x47, 0xFF, 0x59, 0x47, 0xFF, 0x59, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0x0A, 0x4B, 0xFF, 0x0A, 0x4B, 0xFF, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0x00, 0x33, 0x7F, 0x0A, 0x4B, 0xFF, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0x30, 0xF1, 0xFF, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0x0A, 0x4B, 0xFF, 0x0A, 0x4B, 0xFF, 0x0A, 0x4B, 0xFF, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F, 0xFF, 0xF0, 0x4F
};


void rainbow(int hue);
void single_colour();
void led_mapping();
void bitmap_load_and_render(unsigned char* bitmap_data);
unsigned char * decode_image(unsigned char *compressed_image_data, int length);

void setup(){

Serial.begin(112500);
//while(!Serial.dtr())
delay(1000);
Serial.println("Start");

pinMode(LED_BUILTIN, OUTPUT);
//setup leds for fast led
FastLED.addLeds<NEOPIXEL,ControlPin>(leds,NumberOfLeds);

//FastLED.setMaxPowerInVoltsAndMilliamps(5, 500);

led_mapping();
for (int v = 0; v < VPixel; v++){
  Serial.println();
  for (int h = 0; h < HPixel; h++ ){
    Serial.print(mapping[h][v]);
    Serial.print("  ");
  }
}

}

void loop(){
  digitalWrite(LED_BUILTIN, HIGH);
  //static uint8_t hue=0;
  //rainbow(hue++);
  bitmap_load_and_render(&image_data[0]);
  leds.fadeLightBy(240);
  FastLED.delay(5);
  FastLED.show();
  digitalWrite(LED_BUILTIN, LOW);
}

void led_mapping(){
  uint currentLED = 0;
  int ledcounter = 1;
  for (int v = 0; v < VPixel; v++){
    if (currentLED != 0)
      currentLED += 20;
    if (v % 2){
      ledcounter = -1;
    }else{
      ledcounter = 1;
    }
    for (int h = 0; h < HPixel; h++ ){
      mapping[h][v] = currentLED;
      currentLED += ledcounter;
    }
    //offset extra +=
    currentLED -= ledcounter;
  }
}

void rainbow(int hue){

  for (int v = 0; v < VPixel; v++){
    Serial.println();
    int stephue = hue;
    for (int h = 0; h < HPixel; h++ ){
      leds[mapping[h][v]].setHue(stephue);
      stephue += 10;
    }
  }
}

void bitmap_load_and_render(unsigned char *bitmap_data){
  //read size
  uint32_t size;
  memcpy(&size,&bitmap_data[2],4);
  //Serial.println(size);
  // read start of data
  uint32_t dataStart;
  memcpy(&dataStart,&bitmap_data[10],4);
  //Serial.println(dataStart);
  delay(5000);
  //process the image table
  // BGR
  uint32_t currentLocation = dataStart;
  for (int v = 0; v < VPixel; v++){
    for (int h = 0; h < HPixel; h++ ){
      uint8_t blue = bitmap_data[currentLocation];
      currentLocation++;
      uint8_t green = bitmap_data[currentLocation];
      currentLocation++;
      uint8_t red = bitmap_data[currentLocation];
      currentLocation++;
      leds[mapping[h][v]].setRGB(red,green,blue);
    }
  }
}
/*
Used to decode RLE pixel encoded bitmap
REMEMBER TO FREE THE RETURN VALUE AFTER USE!!!!

stil need to deal with padding to multiples of 4
*/
unsigned char * decode_image(unsigned char *compressed_image_data, int length){
  Serial.println("Compressed Data")
  Serial.println(*compressed_image_data);
  unsigned char *image_data;
  image_data = (unsigned char *) malloc(length+1);
  if (image_data == NULL){return NULL;};
  unsigned char data;
  uint16_t position = 0;
  uint8_t rep_num = 1;
  while ((data = compressed_image_data[position]) != EOF){
    rep_num = 1;
    data = compressed_image_data[position];
    // compression signal
    if (data == 0x00){
      // discard header
      position++;
      //get number of repetitions
      rep_num = compressed_image_data[position];
      //move to red data
      position++;
    }

      //might need to memcopy
      //dont change the position, it has to track for uncompressed!
      //red
      unsigned char blue = compressed_image_data[position];
      //green
      unsigned char green = compressed_image_data[position + 1];
     //blue
      unsigned char red = compressed_image_data[position + 2];

      if (rep_num == 0){
        // used to return on end of
        return image_data;
      }

      for (int i = 0; i < rep_num; i++){
        image_data[position] = red;
        position++;
        image_data[position] = green;
        position++;
        image_data[position] = blue;
        position++;
      }

  }
  Serial.println("Uncompressed Data")
  Serial.println(*image_data);
  return image_data;
}
